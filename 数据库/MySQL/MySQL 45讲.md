# MySQL 45 讲

### 01.基础架构

#### 一条sql语句是如何执行的？

1. 建立连接

2. 查询缓存
   
   1. MySQL5.X版本
   
      1. 例如执行select语句
      2. 拿到查询请求后，**先到查询缓存中看看**，是否执行过这条语句
      3. **执行过的语句和其结果以Key-Value的形式缓存在内存中**
      4. 未执行过的语句会继续后面的执行阶段
      5. <font color = "red">因为表改动的几率大，除了静态表（系统表），其余都不建议使用查询缓存。</font>只要有对一个表的更新， 这个表上所有的查询缓存都会被清空，对于更新压力大的数据库来说， 查询缓存的命中率会非常低  
      6. 指定查询缓存的开关：
      7. 将参数query_cache_type设置成DEMAND， 这样对于默认的SQL语句都不使用查询缓存。 
      8. 对于你确定要使用查询缓存的语句， 可以用SQL_CACHE显式指定，例如：
   
      ```sql
      mysql> select SQL_CACHE * from T where ID=10
      ```
   
   2. MySQL**8.X**版本
   
      1. **<font color = "red">将查询缓存的整块功能删掉</font>**  
   
3. 分析器

   1. 没有命中查询缓存这开始执行语句
   2. 首先会做**“词法分析”**，识别是增删改查、什么表、什么列
   3. 随后是**“语法分析”**

4. 优化器

   1. 优化器是在表里面有多个索引的时候，**决定使用哪个索引**； 或者在一个语句有多表关联（join）的时候， **决定各个表的连接顺序**。  

5. 执行器

   1. 开始执行的时候， **要先判断一下你对这个表T有没有执行查询的权限**， 如果没有， 就会返回没有权限的错误  

   2. 比如我们这个例子中的表T中， ID字段**没有索引， 那么执行器的执行流程**是这样的：**<u>（从一到最后依次对比是否是结果值）</u>**

      1. 调用InnoDB引擎接口取这个表的第一行， 判断ID值是不是10， 如果不是则跳过， 如果是则
         将这行存在结果集中；
      2. 调用引擎接口取“下一行”， 重复相同的判断逻辑， 直到取到这个表的最后一行。
      3.  执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

      有索引的表：

      1. 对于**有索引的表， 执行**的逻辑也差不多。 第一次调用的是“取满足条件的第一行”这个接口， 之后循环取“满足条件的下一行”这个接口， 这些接口都是引擎中已经定义好的  **<u>（每次调用去满足接口的一行结果）</u>**

6. ```sql
   /*执行过程例子*/
   mysql> update T set c=c+1 where ID=2;
   ```

   分析器会通过词法和语法解析知道这是一条更新语句。 优化器决定要使用ID这个索引。然后， 执行器负责具体执行， 找到这一行， 然后更新 。

### 02.日志系统

#### 一条SQL更新语句是如何执行的？

书接上文，与查询流程不一样的是，**<u>更新流程</u>**还涉及两个重要的日志模块，**<u>redo log（重做日志） 和 binlog（归档日志）</u>**   

1. redo log （InnoDB引擎日志）
   1. 当有一条记录需要更新的时候， InnoDB引擎就会先把记录写到redo log（粉板） 里面， 并更新内存， 这个时候更新就算完成了。 同时， InnoDB引擎会在适当的时候， 将这个操作记录更新到磁盘（记账本）里面， 而这个更新往往是在系统比较空闲的时候做， 这就像打烊以后掌柜做的
      事 。
   2. **大小是固定的。**因此若redo log满了就会先存一部分到磁盘，腾出空间。会有一个write pos从开头写到最后，在回到开头，不断循环。checkpoint是当前要擦除的位置，擦除前会把记录更新到磁盘文件中
   3. 有了redo log，InnoDB就可以保证即使数据库发生异常重启， 之前提交的记录都不会丢失， 这个能力称为crash-safe  
2. binlog（Server层日志）
   1. 
